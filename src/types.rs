use crate::{ctools, structs, tools};
use crate::structs::{_dtcond, case_component, cpm_cache, ellipsis_candidate, ellipsis_features, ellipsis_svm_features, ellipsis_twin_cand_svm_features, entity_list, predicate_anaphora_list, z_stream_s};

pub type BNST_DATA = tools::tnode_b;
pub type Para_M_ptr = *mut tools::node_para_manager;
pub type PARA_DATA = tools::tnode_p;
pub type Treeptr_B = *mut tools::tnode_b;
pub type SENTENCE_DATA = tools::sentence;
pub type CF_PRED_MGR = tools::cpm_def;
pub type CHECK_DATA = tools::_check;
pub type PARA_MANAGER = tools::node_para_manager;
pub type CLASS = structs::_CLASS;
pub type TYPE = structs::_TYPE;
pub type FEATUREptr = *mut structs::_FEATURE;
pub type FEATURE = structs::_FEATURE;
pub type _IO_lock_t = ();
pub type FILE = structs::_IO_FILE;
pub type time_t = __time_t;
pub type DBM_FILE = *mut structs::CDB_FILE;
pub type ENTITY_MGR = structs::entity_manager;
pub type ENTITY = structs::entity;
pub type CF_ptr = *mut structs::cf_def;
pub type CPM_ptr = *mut structs::cpm_def;
pub type MENTION = structs::mention;
pub type MENTION_MGR = structs::mention_manager;
pub type TAG_DATA = structs::tnode_t;
pub type CASE_FRAME = structs::cf_def;
pub type RuleVector = structs::_RuleVector;
pub type VerboseType = libc::c_uint;
pub type sa_family_t = libc::c_ushort;
pub type jmp_buf = [structs::__jmp_buf_tag; 1];
pub type socklen_t = __socklen_t;
pub type __socket_type = libc::c_uint;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type in_addr_t = uint32_t;
pub type sigset_t = structs::__sigset_t;
pub type __sighandler_t = Option<unsafe extern "C" fn(_: libc::c_int) -> ()>;
pub type __jmp_buf = [libc::c_long; 8];
pub type gid_t = __gid_t;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __mode_t = libc::c_uint;
pub type __pid_t = libc::c_int;
pub type __socklen_t = libc::c_uint;
pub type in_port_t = uint16_t;
pub type size_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type THESAURUS_FILE = structs::thesaurus;
pub type BIN = structs::_BIN;
pub type CELL = structs::_CELL;
pub type CFLIST = structs::cf_list;
pub type __dev_t = libc::c_ulong;
pub type __ino_t = libc::c_ulong;
pub type __nlink_t = libc::c_ulong;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type ELLIPSIS_MGR = structs::ellipsis_list;
pub type ELLIPSIS_CMM = structs::ellipsis_cmm_list;
pub type ELLIPSIS_COMPONENT = structs::ellipsis_component;
pub type CKYptr = *mut structs::_CKY;
pub type CKY = structs::_CKY;
pub type __compar_fn_t = Option<unsafe extern "C" fn(_: *const libc::c_void, _: *const libc::c_void) -> libc::c_int>;
pub type SMLIST = structs::sm_list;
pub type DTCOND = _dtcond;
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type voidpf = *mut libc::c_void;
pub type alloc_func = Option<unsafe extern "C" fn(_: voidpf, _: uInt, _: uInt) -> voidpf>;
pub type free_func = Option<unsafe extern "C" fn(_: voidpf, _: voidpf) -> ()>;
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
pub type PALIST = predicate_anaphora_list;
pub type CASE_COMPONENT = case_component;
pub type E_FEATURES = ellipsis_features;
pub type E_SVM_FEATURES = ellipsis_svm_features;
pub type E_CANDIDATE = ellipsis_candidate;
pub type ENTITY_LIST = entity_list;
pub type E_TWIN_CAND_SVM_FEATURES = ellipsis_twin_cand_svm_features;
pub type CPM_CACHE = cpm_cache;
